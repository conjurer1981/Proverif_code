(*--------channels----------*)
free ch1: channel. (*--public channel, between EVi and GSj, initial authentication--*)
free ch2: channel. (*--public channel, between GSj to EVi, initial authentication--*)
free ch3: channel. (*--public channel, between EVi to GSu, handover authentication--*)
free ch4: channel. (*--public channel, between EVi to GSv, handover authentication--*)
free sch1: channel [private]. (*---private channel, between EVi and CC, registration--*)
free sch2: channel [private]. (*---private channel, between GSj and CC, registration--*)
free sch3: channel [private]. (*---private channel, between GSu and CC, registration--*)
free sch4: channel [private]. (*---private channel, between GSv and CC, registration--*)


(*-------shared keys--------*)
free skij: bitstring [private]. (*---session key between EVi and GSj, generated by EVi--*)
free skji: bitstring [private]. (*---session key between EVi and GSj, generated by GSj--*)
free skui: bitstring [private]. (*---session key between EVi and GSu, generated by EVi--*)
free skiu: bitstring [private]. (*---session key between EVi and GSu, generated by GSu--*)
free skvi: bitstring [private]. (*---session key between EVi and GSv, generated by EVi--*)
free skiv: bitstring [private]. (*---session key between EVi and GSv, generated by GSv--*)

 (*---secret key of CC---*)
free s: bitstring [private].

(*---for Con funcation in OKCN---*)
type pair. (*--the type including two parts---*)
fun con2(bitstring): pair. (*---Con function---*)
fun fst(pair): bitstring. (*---first result retrieving---*)
fun snd(pair): bitstring. (*---second result retrieving---*)


(*--------functions------*)
fun h(bitstring):bitstring. (*---hash function---*)
fun con(bitstring,bitstring):bitstring. (*-----concatenation function---*)
fun add(bitstring,bitstring):bitstring. (*---vector addition----*)
fun mul(bitstring,bitstring):bitstring. (*---vector multiplication----*)
fun xor(bitstring,bitstring):bitstring. (*---exclusive-or-----*)
fun rec(bitstring,bitstring):bitstring. (*---Rec function--*)
fun trans(bitstring):bitstring. (*---transpose function---*)


(*-----constants------------*)
free VIDi:bitstring[private]. (*---EVi's identity---*)
free PWi:bitstring[private]. (*---EVi's password---*)
free ri:bitstring[private]. (*--nonce generated by EVi--*)

const GIDj:bitstring. (*---GSj's identity---*)
const GIDu:bitstring. (*---GSu's identity---*)
const GIDv:bitstring. (*---GSv's identity---*)
const CCID:bitstring. (*---CC's identity---*)
const B:bitstring.    (*----matrix for lattice--*)
table d(bitstring).   (*------table------*)

(*---identity and password can be guessed---*)
weaksecret VIDi. (*--real identity of EVi--*)
weaksecret PWi.  (*--password of EVi--*)

(*---computation rule of XOR---*)
equation forall m:bitstring,n:bitstring; xor(xor(m,n),n)=m.

(*---events--*)
event EV_start1(bitstring). (*--event that EV starts initial authentication--*)
event EV_auth1(bitstring).  (*--event that EV is authenticated on CC--*)
event EV_start2(bitstring). (*--event that EV starts handover with GSu--*)
event EV_auth2(bitstring).  (*--event that EV is authenticated on GSu--*)
event EV_start3(bitstring). (*--event that EV starts handover with GSv--*)
event EV_auth3(bitstring).  (*--event that EV is authenticated on GSv--*)
event GS_start1(bitstring). (*--event that GSj starts initial authentication--*)
event GS_auth1(bitstring).  (*--event that GSj is authenticated on CC--*)
event GS_start2(bitstring). (*--event that GSu starts handover--*)
event GS_auth2(bitstring).  (*--event that GSu is authenticated on EVi--*)
event GS_start3(bitstring). (*--event that GSv starts handover--*)
event GS_auth3(bitstring).  (*--event that GSv is authenticated on EVi--*)

(*--queries--*)
query attacker (VIDi). (*--test if VIDi is away from attacks--*)
query attacker (PWi).  (*--test if PWi is away from attacks--*)
query attacker (skij). (*--test if skij is away from attacks--*)
query attacker (skji). (*--test if skji is away from attacks--*)
query attacker (skui). (*--test if skui is away from attacks--*)
query attacker (skiu). (*--test if skiu is away from attacks--*)
query attacker (skiv). (*--test if skiv is away from attacks--*)
query attacker (skvi). (*--test if skvj is away from attacks--*)
query attacker (s).    (*--test if s is away from attacks--*)

query x:bitstring; inj-event(EV_auth1(x))==>inj-event(EV_start1(x)).(*-Injective correspondence: each EV_auth1(x) implies a unique EV_start1(x) event-*)
query x:bitstring; inj-event(EV_auth2(x))==>inj-event(EV_start2(x)).(*-Injective correspondence: each EV_auth2(x) implies a unique EV_start2(x) event-*)
query x:bitstring; inj-event(EV_auth3(x))==>inj-event(EV_start3(x)).(*-Injective correspondence: each EV_auth3(x) implies a unique EV_start3(x) event-*)
query x:bitstring; inj-event(GS_auth1(x))==>inj-event(GS_start1(x)).(*-Injective correspondence: each GS_auth1(x) implies a unique GS_start1(x) event-*)
query x:bitstring; inj-event(GS_auth2(x))==>inj-event(GS_start2(x)).(*-Injective correspondence: each GS_auth2(x) implies a unique GS_start2(x) event-*)
query x:bitstring; inj-event(GS_auth3(x))==>inj-event(GS_start3(x)).(*-Injective correspondence: each GS_auth3(x) implies a unique GS_start3(x) event-*)



(*------EV process---------*)
let EV=
  (*--registration phase--*)
  new ri:bitstring; (*--generate ri--*)
  let HPWi = h(con(ri,PWi)) in (*--compute HPWi--*)
  out(sch1,(VIDi,HPWi)); (*--send registration information to CC via private channel sch1--*)
  in(sch1,(RI1:bitstring,RI2:bitstring,PIDi:bitstring)); (*--receive response from CC  via private channel sch1--*)
  let RI3 = xor(h(con(VIDi,HPWi)),ri)  in (*--EVi stores RI3--*)
  !  (*--authentication--*)
  (
    (*---intial authentication--*)
  event EV_start1(VIDi); (*--EVi starts to make authentication with GSj--*)
  (*--random numbers--*)
  new si:bitstring;
  new ei:bitstring;
  new ai:bitstring;
  new ti:bitstring;
  (*--authentication element computation---*)
  let ri1 = xor(RI3,h(con(VIDi,PWi))) in
  let HPWi1 = h(con(ri1,PWi)) in
  let pi = add(mul(B,si),ei) in
  let A1 = xor(xor(RI1,HPWi1),ai) in 
  let A2 = xor(h(con(PIDi,ai)),VIDi) in
  let A3 = h(con(con(con(con(con(PIDi,VIDi),GIDj),ai),h(pi)),ti)) in
  let M1 = (PIDi,pi,A1,A2,A3,ti) in  (*--construct M1---*)
  out(ch1,M1); (*--send M1--*)
  (*--get response from GSj and make confirmation--*)
  in (ch1,(EVA8:bitstring,EVA10:bitstring,EVA11:bitstring,EVpj:bitstring,EVvj:bitstring,EVA13:bitstring,EVA14:bitstring,EVA15:bitstring,EVtCC:bitstring));
  let A16 = xor(EVA8,h(con(ai,PIDi))) in
  let PIDinew = xor(EVA10,h(con(xor(RI2,h(con(VIDi,HPWi1))),ai))) in
  if EVA11 = h(con(con(con(con(PIDinew,VIDi),A16),ai),EVtCC)) then  
  new ei2:bitstring;
  let bi = add(mul(trans(EVpj),si),ei2) in
  let ki = rec(bi,EVvj) in 
  let skij = h(con(con(con(pi,EVpj),EVvj),ki)) in  (*--build session key between EVi and GSj--*)
  let EVTj = xor(EVA13,h(con(EVpj,ki))) in
  let TIDiu = xor(EVA14,h(con(ki,EVpj))) in
  if EVA15 = h(con(con(con(con(con(GIDj,PIDi),skij),EVTj),TIDiu),EVtCC)) then
  (*--data updating--*)
  let RI1new = xor(A16,HPWi1) in
  let RI1 = RI1new in
  let PIDi = PIDinew in

  (*-----handover----*)
  event EV_start2(TIDiu); (*--EVi starts to make authentication with GSu--*)
  (*--random numbers--*)
  new siu:bitstring;
  new eiu:bitstring;
  new tiu:bitstring;
   (*--authentication element computation---*)
  let piu = add(mul(B,siu),eiu) in
  let B1 = xor(h(con(piu,h(con(con(TIDiu,EVTj),GIDu)))),EVTj) in 
  let B2 = h(con(con(con(con(TIDiu,GIDu),piu),EVTj),tiu)) in
  let M5 = (TIDiu,B1,B2,piu,tiu) in  (*--constructing M5--*)
  out(ch3,M5); (*--send M5--*)
  (*--get response from GSu and make confirmation--*)
  in(ch3,(EVpu:bitstring,EVvu:bitstring,EVB3:bitstring,EVB4:bitstring,EVB5:bitstring,EVtGSu:bitstring));
  new eiu2:bitstring;
  let biu = add(mul(trans(EVpu),siu),eiu2) in
  let kiu = rec(biu,EVvu) in
  let skiu = h(con(con(con(piu,EVpu),EVvu),kiu)) in  (*--build session key between EVi and GSu--*)
  (*--get information for next handover--*)
  let EVTu = xor(EVB3,h(con(EVpu,kiu))) in 
  let TIDiv = xor(EVB4,h(con(kiu,EVpu))) in
  if EVB5 = h(con(con(con(con(con(GIDu,TIDiv),skiu),EVTu),TIDiv),EVtGSu)) then
  event GS_auth2(GIDu); (*---GSu is authenticated--*)

  (*---handover at last GSv--*)
  event EV_start3(TIDiv); (*--EVi starts to make authentication with GSv--*)
  (*--random numbers--*)
  new siv:bitstring;
  new eiv:bitstring;
  new tiv:bitstring;
   (*--authentication element computation---*)
  let piv = add(mul(B,siv),eiv) in 
  let Bv1 = xor(h(con(piv,h(con(con(TIDiv,EVTu),GIDv)))),EVTu) in 
  let Bv2 = h(con(con(con(con(TIDiv,GIDv),piv),EVTu),tiv)) in
  let M7 = (TIDiv,Bv1,Bv2,piv,tiv) in  (*--constructing M7--*)
  out(ch4,M7); (*--send M7--*)
  (*--get response from GSv and make confirmation--*)
  in(ch4,(EVpv:bitstring,EVvv:bitstring,EVBv3:bitstring,EVBv4:bitstring,EVBv5:bitstring,EVtGSv:bitstring));
  let bi3 = add(mul(trans(EVpv),siv),eiv) in
  let ki3 = rec(bi3,EVvv) in
  let skiv = h(con(con(con(piv,EVpv),EVvv),ki3)) in  (*--build session key between EVi and GSv--*)
  let EVTv = xor(EVBv3,h(con(EVpv,ki3))) in 
  if EVB5 = h(con(con(con(con(GIDv,TIDiv),skiv),EVTv),EVtGSv)) then
  event GS_auth3(GIDv); (*---GSv is authenticated--*)
  0
  ).


(*------GSj's process----*)  
(*--registration phase---*)
let GSj =
  in(sch2, GSkGSjCC:bitstring); (*--send registration data to CC via private channel sch2--*)
  !  (*authentication*)
 (
  in(ch1,(GSPIDi:bitstring,GSpi:bitstring,GSA1:bitstring,GSA2:bitstring,GSA3:bitstring,GSti:bitstring));
  event GS_start1(GIDj); (*GSj starts to make authentication with CC*)
  (*random numbers*)
  new rj: bitstring;
  let A4 = xor(h(con(GIDj,GSkGSjCC)),rj) in
  let A5 = xor(h(rj), h(GSpi)) in
  let A6 = h(con(con(con(con(GSkGSjCC,rj),GIDj),h(GSpi)),GSti)) in
  let M2 = (GSPIDi,GSA1,GSA2,GSA3,A4,A5,A6,GSti) in  (*--constructing M2---*)
  out (ch2,M2);  (*send M2*)
   (*--get response from CC and make confirmation--*)
  in(ch2,(GSA8:bitstring,GSA10:bitstring,GSA11:bitstring,GSA12:bitstring,GStCC:bitstring));
  if GSA12 = h(con(con(GSkGSjCC,rj),GStCC)) then
  new GSTIDiu:bitstring;
  new sj:bitstring;
  new ej:bitstring;
  new ej2:bitstring;
  let pj = add(mul(trans(B),sj),ej) in
  let bj = add(mul(trans(sj),GSpi),ej2) in
  let rtj = con2(bj) in
  let kj = fst(rtj) in
  let vj = snd(rtj) in
  let skji = h(con(con(con(GSpi,pj),vj),kj)) in  (*--build session key between EVi and GSj--*)
  let Tj = h(con(con(con(con(GIDj,GSPIDi),skji),GSti),GStCC)) in
  let A13 = xor(h(con(pj,kj)),Tj) in
  let A14 = xor(h(con(kj,pj)),GSTIDiu) in
  let A15 = h(con(con(con(con(con(GIDj,GSPIDi),skji),Tj),GSTIDiu),GStCC)) in 
  let M3 = (GSA8,GSA10,GSA11,pj,vj,A13,A14,A15,GStCC) in (*--constructing M3--*)
  let Mtrans = (GSTIDiu,Tj) in (*--construct message for EVi's next handover to blockchain--*)
  out(ch1,M3);  (*send M3*)
  out(sch3,Mtrans); (*send message to blockchain*)
  0
  ). 

let GSu =
(*registration*)
   in(sch3, GSkGSuCC:bitstring); (*--send registration data to CC via private channel sch3--*)
  ! (*authentication*)
 (
  in(sch4,(GSTIDiu:bitstring,GSuTj:bitstring)); (*read information from blockchain*)
  in(ch3,(GS2TIDiu:bitstring,GS2B1:bitstring,GS2B2:bitstring,GS2piu:bitstring,GS2tiu:bitstring));
  if GSTIDiu = GS2TIDiu then
  if GSuTj = xor(GS2B1,h(con(con(con(GS2piu,GSTIDiu),GSuTj),GIDu))) then
  if GS2B2 = h(con(con(con(con(GS2TIDiu,GIDu),GS2piu),GSuTj),GS2tiu)) then
  event EV_auth2(GS2TIDiu); (*EVi is authenticated*)
  event GS_start2(GIDu); (*GSu starts to make authentication with EVi*)
  (*random numbers*)
  new su:bitstring; 
  new eu:bitstring;
  new eu2:bitstring;
  new GSTIDiv:bitstring;
  new tGSu:bitstring;
  let pu = add(mul(trans(B),su), eu) in
  let bu = add(mul(trans(su),GS2piu),eu2) in
  let rtu = con2(bu) in
  let ku = fst(rtu) in
  let vu = snd(rtu) in
  let skui = h(con(con(con(GS2piu,pu),vu),ku)) in  (*--build session key between EVi and GSu--*)
  let Tu = h(con(con(con(GIDu,GS2TIDiu),skui),tGSu)) in 
  let B3 = xor(h(con(pu,ku)),Tu) in
  let B4 = xor(h(con(ku,pu)),GSTIDiv) in
  let B5 = h(con(con(con(con(con(GIDu,GS2TIDiu),skui),Tu),GSTIDiv),tGSu)) in
  let M6 = (pu,vu,B3,B4,B5,tGSu) in  (*--construct M6--*)
  let Mtrans2 = (GSTIDiv,Tu) in  (*--construct message for EVi's next handover to blockchain--*)
  out (ch3,M6); (*send M6*)
  out (sch4,Mtrans2); (*send message to blockchain*)
  0
  ). 

let GSv =
(*--registration--*)
   in(sch4, GSkGSvCC:bitstring); (*--send registration data to CC via private channel sch4--*)
  !  (*authentication*)
 (
  in(sch4,(GSTIDiv:bitstring,GSvTu:bitstring)); (*read information from blockchain*)
  in(ch3,(GS3TIDiv:bitstring,GS3B1:bitstring,GS3B2:bitstring,GS3piv:bitstring,GS3tiv:bitstring));
  if GSTIDiv = GS3TIDiv then
  if GSvTu = xor(GS3B1,h(con(con(con(GS3piv,GS3TIDiv),GSvTu),GIDv))) then
  if GS3B2 = h(con(con(con(con(GS3TIDiv,GIDv),GS3piv),GSvTu),GS3tiv)) then
  event EV_auth3(GS3TIDiv); (*EVi is authenticated*)
  event GS_start3(GIDv); (*GSv starts to make authentication with Evi*)
  (*random numbers*)
  new sv:bitstring; 
  new ev:bitstring;
  new ev2:bitstring;
  new tGSv:bitstring;
  let pv = add(mul(trans(B),sv),ev) in
  let bv = add(mul(trans(sv),GS3piv),ev2) in
  let rtv = con2(bv) in
  let kv = fst(rtv) in
  let vv = snd(rtv) in
  let skvi = h(con(con(con(GS3piv,pv),vv),kv)) in  (*---build session key between EVi and GSv--*)
  let Tv = h(con(con(con(GIDv,GS3TIDiv),skvi),tGSv)) in 
  let Bv3 = xor(h(con(pv,kv)),Tv) in
  let Bv4 = xor(h(con(kv,pv)),GS3TIDiv) in
  let Bv5 = h(con(con(con(con(GIDv,GS3TIDiv),skvi),Tv),tGSv)) in
  let M8 = (pv,vv,Bv3,Bv4,Bv5,tGSv) in (*construct M8*)
  out (ch4,M8); (*--send M8--*)
  0
  ).
  
  
(*------CC's process-------*)
let CCReg1 =  (*--EVi registration --*)
  in(sch1,(CCVIDi:bitstring,CCHPWi:bitstring));
  new CCPIDi: bitstring;
  let CCRI1=xor(h(con(CCPIDi,s)),CCID) in
  let CCRI2=xor( h(con(CCVIDi,s)),h(con(CCVIDi,CCHPWi))) in
  insert d(CCVIDi);
  out (sch1,(CCRI1,CCRI2,CCPIDi)).

let CCReg2 = (*GSj regisgtration*)
   let kGSjCC = h(con(con(GIDj,CCID),s)) in
   out (sch2,kGSjCC).

let CCReg3 = (*GSu regisgtration*)
   let kGSuCC = h(con(con(GIDu,CCID),s)) in
   out (sch3,kGSuCC).

let CCReg4 = (*GSv regisgtration*)
   let kGSvCC = h(con(con(GIDv,CCID),s)) in
   out (sch4,kGSvCC). 

(*authentication with EVi and GSj*)
let CCAuth =
  in(ch2,(CCPIDi1:bitstring,CCA1:bitstring,CCA2:bitstring,CCA3:bitstring,CCA4:bitstring,CCA5:bitstring,CCA6:bitstring,CCti:bitstring));
  let CCai = xor(CCA1,h(con(con(CCPIDi1,s),CCID))) in
  let CCVIDi = xor(CCA2,h(con(CCPIDi1,CCai))) in
  get d(=CCVIDi) in (*search VIDi*)
  let kGSjCC = h(con(con(GIDj,CCID),s)) in 
  let CCrj = xor(CCA4,h(con(GIDj,kGSjCC))) in
  let hp = xor(CCA5,h(CCrj)) in
  if CCA3 = h(con(con(con(con(con(CCPIDi1,CCVIDi),GIDj),CCai),hp),CCti)) then
  event EV_auth1(CCVIDi); (*--EVi is authenticated--*)
  if CCA6 = h(con(con(con(con(kGSjCC,CCrj),GIDj),hp),CCti)) then
  event GS_auth1(GIDj);  (*--GSj is authenticated--*)
  new CCPIDinew: bitstring;
  new CCtCC:bitstring;
  let CCA7 = h(con(con(CCPIDinew,s),CCID)) in
  let CCA8 = xor(CCA7,h(con(CCai,CCPIDi1))) in
  let CCA9 = h(con(CCVIDi,s)) in
  let CCA10 = xor(h(con(CCA9,CCai)),CCPIDinew) in
  let CCA11 = h(con(con(con(con(CCPIDinew,CCVIDi),CCA7),CCai),CCtCC)) in
  let CCA12 = h(con(con(kGSjCC,CCrj),CCtCC)) in
  let M3 =(CCA8,CCA10,CCA11,CCA12,CCtCC) in  (*construct M3*)
  out(ch2,M3). (*send M3*)
  
 (* Main process: parallel composition of all components *)
(* CC combines CCReg1, CCReg2, CCReg3, and CCAuth in parallel *)
  let CC = CCReg1 | CCReg2 | CCReg3 | CCAuth.
 (* Final process definition: all components run concurrently *)
  process !EV | !GSj | !GSu | !GSv | !CC







 
  








